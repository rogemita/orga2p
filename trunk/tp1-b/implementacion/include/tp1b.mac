;========================
; MACRO obtenerBajo
;========================
; Recupera la parte alta de un dato empaquetado a byte
; Entrada:
;	registro1	registros sobre los cuales operar 
;	registro2
;	registro3
;	offset		indica si debe desplazar el dato original
;========================
%macro obtenerBajo 2-3 0
	movq		%1, %2		;copio el dato
%if %3 != 0
	psrlq		%1, %3		;desplazo dos columnas
%endif
	punpcklbw	%1, %1		;desempaqueto la parte baja
	psllw		%1, 8		;retiro el excedente alto
	psrlw		%1, 8
%endmacro

%macro obtenerAlto 2-3 0
	movq		%1, %2		;copio el dato
%if %3 != 0
	psrlq		%1, %3		;desplazo dos columnas
%endif
	punpckhbw	%1, %1		;desempaqueto la parte baja
	psllw		%1, 8		;retiro el excedente alto
	psrlw		%1, 8
%endmacro      

;========================
; MACRO sobelPrewittX
;========================
; Cuerpo de codigo que aplica los operadores de Sobel y Prewitt en el orden x
; Entrada:
;	registro1	registros sobre los cuales operar 
;	registro2
;	registro3
;	duplica?	debe duplicar el valor del primer registro?
;	procesaAmbos	indica si debe procesar el dato bajo y el alto
;========================
%macro	sobelPrewittX 4-5 0
	;**************************
	; VOY A APLICAR EL OPERADOR
	; EN LA PARTE BAJA
	;**************************
	obtenerBajo	mm6, %2, 16	;obtengo los bajos de la segunda fila
%if %4 = 0
	psllw		mm6, 1		;multiplico por dos
%endif
	obtenerBajo	mm7, %1, 16	;obtengo los bajos de la primera fila
	paddusw		mm6, mm7	;sumo saturado
	obtenerBajo	mm7, %3, 16	;obtengo los bajos de la tercera fila
	paddusw		mm6, mm7	;sumo saturado

	obtenerBajo	mm7, %2		;obtengo los bajos de la segunda fila
%if %4 = 0
	psllw		mm7, 1		;multiplico por dos
%endif
	psubusw		mm6, mm7
	obtenerBajo	mm7, %1		;obtengo los bajos de la primera fila
	psubusw		mm6, mm7	;sumo saturado
	obtenerBajo	mm7, %3		;obtengo los bajos de la tercera fila
	psubusw		mm6, mm7	;sumo saturado

	;************************
	; TERMINE COPIO A DESTINO
	;************************
	packuswb	mm6, mm6
	movd		[eax], mm6	;copio los 4 bytes al destino
	
%if %5 = 0
	add		eax, 4	;salto la linea siguiente
	
	;**************************
	; VOY A APLICAR EL OPERADOR
	; EN LA PARTE ALTA
	;**************************	
	obtenerAlto	mm6, %2, 16	;obtengo los bajos de la segunda fila
%if %4 = 0
	psllw		mm6, 1		;multiplico por dos
%endif
	obtenerAlto	mm7, %1, 16	;obtengo los bajos de la primera fila
	paddusw		mm6, mm7	;sumo saturado
	obtenerAlto	mm7, %3, 16	;obtengo los bajos de la tercera fila
	paddusw		mm6, mm7	;sumo saturado

	obtenerAlto	mm7, %2		;obtengo los bajos de la segunda fila
%if %4 = 0
	psllw		mm7, 1		;multiplico por dos
%endif
	psubusw		mm6, mm7
	obtenerAlto	mm7, %1		;obtengo los bajos de la primera fila
	psubusw		mm6, mm7	;sumo saturado
	obtenerAlto	mm7, %3		;obtengo los bajos de la tercera fila
	psubusw		mm6, mm7	;sumo saturado

	;************************
	; TERMINE COPIO A DESTINO
	;************************
	packuswb	mm6, mm6
	movd		[eax], mm6	;copio los 4 bytes al destino de los cuales 2 son validos
	sub		eax, 4
%endif
	add		eax, edx	;salto la linea siguiente
%endmacro

;========================
; MACRO sobelPrewittY
;========================
; Cuerpo de codigo que aplica los operadores de Sobel y Prewitt en el orden x
; Entrada:
;	registro1	registros sobre los cuales operar 
;	registro2
;	registro3
;	duplica?	debe duplicar el valor del primer registro?
;	procesaAmbos	indica si debe procesar el dato bajo y el alto
;========================
%macro	sobelPrewittY 2-3 0
	;**********************
	; PROCESO PIXEL 2,4,6,8
	;**********************
	movq	mm5, %1			;cargo el primer registro y enmascaro para pasar a word
	pand	mm5, mm7
	movq	mm6, %1			;cargo y me quedo con el pixel una a derecha
	psllq	mm6, 8
	pand	mm6, mm7
%if %3 = 0
	psllw	mm6, 1			;multiplico por dos
%endif
	paddusw	mm5, mm6		;sumo el segundo pixel
	movq	mm6, %1
	psllq	mm6, 16			;cargo y me quedo con el pixel dos a derecha
	pand	mm6, mm7
	paddusw	mm5, mm6		; ya tengo acumulado en mm5 la parte positiva de los pixeles, 2, 4, 6, 8

	movq	mm6, %2
	pand	mm6, mm7
	psubusw	mm5, mm6
	movq	mm6, %2
	psllq	mm6, 8
	pand	mm6, mm7
%if %3 = 0
	psllw	mm6, 1			;multiplico por dos
%endif	
	psubusw	mm5, mm6
	movq	mm6, %2
	psllq	mm6, 16			;cargo y me quedo con el pixel dos a derecha
	pand	mm6, mm7
	psubusw	mm5, mm6		; ya el operador aplicado en mm5 a los pixeles, 2, 4, 6, 8
	pxor	mm6, mm6
	packuswb	mm5, mm6
	punpcklbw	mm5, mm6	;saturo los pixeles
	por	mm5, [eax]
	movq	[eax], mm5		;copio los pixeles

	;**********************
	; PROCESO PIXEL 1,3,5
	;**********************
	movq	mm5, %1			;cargo el primer registro y enmascaro para pasar a word
	psrlq	mm5, 8
	pand	mm5, mm7
	movq	mm6, %1			;cargo y me quedo con el pixel una a derecha
	pand	mm6, mm7
%if %3 = 0
	psllw	mm6, 1			;multiplico por dos
%endif
	paddusw	mm5, mm6		;sumo el segundo pixel
	movq	mm6, %1
	psllq	mm6, 8			;cargo y me quedo con el pixel dos a derecha
	pand	mm6, mm7
	paddusw	mm5, mm6		; ya tengo acumulado en mm5 la parte positiva de los pixeles, 1, 3, 5

	movq	mm6, %2
	psrlq	mm6, 8
	pand	mm6, mm7
	psubusw	mm5, mm6
	movq	mm6, %2
	pand	mm6, mm7
%if %3 = 0
	psllw	mm6, 1			;multiplico por dos
%endif	
	psubusw	mm5, mm6
	movq	mm6, %2
	psllq	mm6, 8			;cargo y me quedo con el pixel dos a derecha
	pand	mm6, mm7
	psubusw	mm5, mm6		; ya el operador aplicado en mm5 a los pixeles, 2, 4, 6, 8

	pxor	mm6, mm6
	packuswb	mm5, mm6
	punpcklbw	mm5, mm6	;saturo los pixeles
	psllq	mm5, 8
	por	mm5, [eax]
	movq	[eax], mm5		;copio los pixeles

	add		eax, edx	;salto la linea siguiente
%endmacro
